---
alwaysApply: true
---
# Arc: Architectural Philosophy & Guiding Principles

This document outlines the core principles and architectural philosophy of Arc. It serves as a high-level guide for developers, focusing on the "why" behind our technical decisions to ensure we build a consistent, maintainable, and scalable application.

## 1. Core Principles

Our architecture is founded on two principles that dictate how we design, build, and reason about our codebase.

### 1.1. Consumer-First Design

> **The design of any layer or package must be guided by the experience of its consumer.**

We build our APIs from the outside in. When designing `@arc/core`, we think like UI developers. When designing `@arc/ai`, we think like `@arc/core` developers. This principle ensures our APIs are elegant and intuitive, prioritizing usability over implementation convenience. **Usage guides implementation, not the other way around.**

### 1.2. A Strictly Layered Architecture

> **Higher layers demand, lower layers fulfill.**

Arc is organized into three distinct layers. Dependencies must always point inwards, from a higher layer to a lower one. A lower-level module must **never** import from a higher-level one.

1.  **Application Layer (Highest):** The user-facing applications (`web`, `desktop`, `mobile`).
2.  **Core Layer (Middle):** The headless business logic backend (`@arc/core`).
3.  **Module Layer (Lowest):** Specialized packages (`@arc/ai`, `@arc/db`, `@arc/platform`).

This structure creates a clear flow of control. The Application layer *demands* functionality, the Core layer *orchestrates* it, and the Module layer *fulfills* the specific I/O and AI provider requests.

## 2. Architecture in Practice

Our principles are realized through a clean, decoupled architecture.

```
Platform (Web | Electron | Capacitor)
↕
UI Layer (Next.js + shadcn/ui)
↕
Headless Core (TypeScript)
```

-   **The UI Layer: The Demander.** The UI's primary role is to handle user interaction and translate it into demands on the Headless Core. It is the ultimate consumer of the system's business logic.

-   **The Headless Core: The Orchestrator.** `@arc/core` is a platform-agnostic engine that contains all business logic. It acts as a facade, fulfilling the UI's demands by orchestrating the specialized modules below it. It knows *what* to do, but not *how* it's done on a specific platform.

-   **The Platform Layer: The Fulfiller.** The unified `@arc/platform` package is the ultimate Fulfiller. It provides the Core with concrete implementations for platform-specific capabilities like database access and file system I/O. This dependency injection mechanism allows the Core to remain portable and unaware of its environment.

### Monorepo Structure

This philosophy is reflected in our pnpm monorepo structure, where packages are organized by their layer and role.

```
/
├─ apps/
│  ├─ web/                # Next.js UI (The Demander)
│  ├─ desktop/            #
│  └─ mobile/             #
│
└─ packages/
   ├─ core/               # Headless TS core (The Orchestrator)
   ├─ ai/                 # Specialized Fulfillers
   ├─ db/                 #
   └─ platform/           # The Ultimate Fulfiller
```

## 3. Key Architectural Patterns

To protect this architecture, we enforce several critical development patterns. These are not just suggestions; they are essential for maintaining a clean codebase.

### 3.1. Module-Owned Contracts

To maintain the strict, one-way dependency flow, we have no central `contracts` package. Instead, **each low-level module defines and owns its own contracts**. For example, the `Provider` interface is defined in `@arc/ai`. `@arc/core` then imports this contract, ensuring dependencies only point inwards.

### 3.2. No Barrel Imports

Barrel files (`index.ts`) that re-export modules are strictly forbidden. They obscure the dependency graph and break tree-shaking. **Always import directly from the source file.**

### 3.3. Strict Platform Isolation

Platform-specific code must be strictly isolated to prevent it from leaking into the wrong environment (e.g., Node.js APIs in the browser). Our `sql.js` integration is a prime example, where we use a multi-layered dynamic import strategy to ensure it's only ever loaded in a browser context, keeping our Core and UI layers pure.

## 4. Development Guide

### Technology Stack

-   **UI & Web App:** Next.js 15, shadcn/ui, Tailwind CSS 4
-   **Desktop Wrapper:** Electron 38
-   **Mobile Wrapper:** Capacitor 7
-   **Data Persistence:** SQLite (via platform-specific drivers)
-   **Core Logic:** Pure TypeScript (ESM)
-   **Monorepo Management:** pnpm & Turborepo

### Build Strategy

Arc uses a static-first build strategy for maximum portability and performance. The Next.js app is exported as a static site (`output: 'export'`), removing the need for a Node.js server at runtime. Electron and Capacitor apps load these static assets directly.

### UI/UX Philosophy

Our design philosophy is "Feels like ChatGPT, works like a power tool." The UI prioritizes simplicity for new users while making advanced features accessible through progressive disclosure:

-   **Level 1 (Beginner):** A simple, familiar chat interface.
-   **Level 2 (Intermediate):** Contextual actions (copy, regenerate) and basic settings.
-   **Level 3 (Power User):** Advanced features like multi-provider setup and model tuning are in dedicated settings.
